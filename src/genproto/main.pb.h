// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: main.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_main_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_main_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_main_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_main_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_main_2eproto;
class CameraEvent;
struct CameraEventDefaultTypeInternal;
extern CameraEventDefaultTypeInternal _CameraEvent_default_instance_;
class CameraEvent_Position;
struct CameraEvent_PositionDefaultTypeInternal;
extern CameraEvent_PositionDefaultTypeInternal _CameraEvent_Position_default_instance_;
class CameraEvent_Rotation;
struct CameraEvent_RotationDefaultTypeInternal;
extern CameraEvent_RotationDefaultTypeInternal _CameraEvent_Rotation_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class MouseMoveEvent;
struct MouseMoveEventDefaultTypeInternal;
extern MouseMoveEventDefaultTypeInternal _MouseMoveEvent_default_instance_;
class RendererEvent;
struct RendererEventDefaultTypeInternal;
extern RendererEventDefaultTypeInternal _RendererEvent_default_instance_;
class RendererEvent_Block;
struct RendererEvent_BlockDefaultTypeInternal;
extern RendererEvent_BlockDefaultTypeInternal _RendererEvent_Block_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum CameraEvent_Type : int {
  CameraEvent_Type_FORWARD = 0,
  CameraEvent_Type_BACKWARD = 1,
  CameraEvent_Type_LEFT = 2,
  CameraEvent_Type_RIGHT = 3,
  CameraEvent_Type_UP = 4,
  CameraEvent_Type_DOWN = 5,
  CameraEvent_Type_FOV_INCREASE = 6,
  CameraEvent_Type_FOV_DECREASE = 7,
  CameraEvent_Type_PITCH_YAW = 8,
  CameraEvent_Type_SCENE_POSITION = 9,
  CameraEvent_Type_CameraEvent_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CameraEvent_Type_CameraEvent_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CameraEvent_Type_IsValid(int value);
extern const uint32_t CameraEvent_Type_internal_data_[];
constexpr CameraEvent_Type CameraEvent_Type_Type_MIN = static_cast<CameraEvent_Type>(0);
constexpr CameraEvent_Type CameraEvent_Type_Type_MAX = static_cast<CameraEvent_Type>(9);
constexpr int CameraEvent_Type_Type_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
CameraEvent_Type_descriptor();
template <typename T>
const std::string& CameraEvent_Type_Name(T value) {
  static_assert(std::is_same<T, CameraEvent_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return CameraEvent_Type_Name(static_cast<CameraEvent_Type>(value));
}
template <>
inline const std::string& CameraEvent_Type_Name(CameraEvent_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CameraEvent_Type_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool CameraEvent_Type_Parse(absl::string_view name, CameraEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraEvent_Type>(
      CameraEvent_Type_descriptor(), name, value);
}
enum RendererEvent_Type : int {
  RendererEvent_Type_LOAD_UPLOADED_SCENE = 0,
  RendererEvent_Type_DOWNLOAD_SCENE_SNAPSHOT = 1,
  RendererEvent_Type_GPU_NUMBER = 2,
  RendererEvent_Type_STREAMS_PER_GPU = 3,
  RendererEvent_Type_SAMPLES_PER_PIXEL = 4,
  RendererEvent_Type_RECURSION_DEPTH = 5,
  RendererEvent_Type_THREAD_BLOCK_SIZE = 6,
  RendererEvent_Type_IMAGE_RESOLUTION = 7,
  RendererEvent_Type_SHOW_TASK_GRID = 8,
  RendererEvent_Type_LOAD_BALANCING_ALGORITHM = 9,
  RendererEvent_Type_RendererEvent_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RendererEvent_Type_RendererEvent_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RendererEvent_Type_IsValid(int value);
extern const uint32_t RendererEvent_Type_internal_data_[];
constexpr RendererEvent_Type RendererEvent_Type_Type_MIN = static_cast<RendererEvent_Type>(0);
constexpr RendererEvent_Type RendererEvent_Type_Type_MAX = static_cast<RendererEvent_Type>(9);
constexpr int RendererEvent_Type_Type_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
RendererEvent_Type_descriptor();
template <typename T>
const std::string& RendererEvent_Type_Name(T value) {
  static_assert(std::is_same<T, RendererEvent_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RendererEvent_Type_Name(static_cast<RendererEvent_Type>(value));
}
template <>
inline const std::string& RendererEvent_Type_Name(RendererEvent_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RendererEvent_Type_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool RendererEvent_Type_Parse(absl::string_view name, RendererEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RendererEvent_Type>(
      RendererEvent_Type_descriptor(), name, value);
}
enum RendererEvent_LoadBalancingAlgorithm : int {
  RendererEvent_LoadBalancingAlgorithm_FST = 0,
  RendererEvent_LoadBalancingAlgorithm_DTFL = 1,
  RendererEvent_LoadBalancingAlgorithm_DT = 2,
  RendererEvent_LoadBalancingAlgorithm_RendererEvent_LoadBalancingAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RendererEvent_LoadBalancingAlgorithm_RendererEvent_LoadBalancingAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RendererEvent_LoadBalancingAlgorithm_IsValid(int value);
extern const uint32_t RendererEvent_LoadBalancingAlgorithm_internal_data_[];
constexpr RendererEvent_LoadBalancingAlgorithm RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_MIN = static_cast<RendererEvent_LoadBalancingAlgorithm>(0);
constexpr RendererEvent_LoadBalancingAlgorithm RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_MAX = static_cast<RendererEvent_LoadBalancingAlgorithm>(2);
constexpr int RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RendererEvent_LoadBalancingAlgorithm_descriptor();
template <typename T>
const std::string& RendererEvent_LoadBalancingAlgorithm_Name(T value) {
  static_assert(std::is_same<T, RendererEvent_LoadBalancingAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoadBalancingAlgorithm_Name().");
  return RendererEvent_LoadBalancingAlgorithm_Name(static_cast<RendererEvent_LoadBalancingAlgorithm>(value));
}
template <>
inline const std::string& RendererEvent_LoadBalancingAlgorithm_Name(RendererEvent_LoadBalancingAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RendererEvent_LoadBalancingAlgorithm_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RendererEvent_LoadBalancingAlgorithm_Parse(absl::string_view name, RendererEvent_LoadBalancingAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RendererEvent_LoadBalancingAlgorithm>(
      RendererEvent_LoadBalancingAlgorithm_descriptor(), name, value);
}
enum Event_EventType : int {
  Event_EventType_UNKNOWN = 0,
  Event_EventType_MOUSE_MOVE = 1,
  Event_EventType_CAMERA_EVENT = 2,
  Event_EventType_RENDERER_EVENT = 3,
  Event_EventType_Event_EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Event_EventType_Event_EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Event_EventType_IsValid(int value);
extern const uint32_t Event_EventType_internal_data_[];
constexpr Event_EventType Event_EventType_EventType_MIN = static_cast<Event_EventType>(0);
constexpr Event_EventType Event_EventType_EventType_MAX = static_cast<Event_EventType>(3);
constexpr int Event_EventType_EventType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Event_EventType_descriptor();
template <typename T>
const std::string& Event_EventType_Name(T value) {
  static_assert(std::is_same<T, Event_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return Event_EventType_Name(static_cast<Event_EventType>(value));
}
template <>
inline const std::string& Event_EventType_Name(Event_EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Event_EventType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Event_EventType_Parse(absl::string_view name, Event_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_EventType>(
      Event_EventType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RendererEvent_Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RendererEvent.Block) */ {
 public:
  inline RendererEvent_Block() : RendererEvent_Block(nullptr) {}
  ~RendererEvent_Block() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RendererEvent_Block(
      ::google::protobuf::internal::ConstantInitialized);

  inline RendererEvent_Block(const RendererEvent_Block& from) : RendererEvent_Block(nullptr, from) {}
  inline RendererEvent_Block(RendererEvent_Block&& from) noexcept
      : RendererEvent_Block(nullptr, std::move(from)) {}
  inline RendererEvent_Block& operator=(const RendererEvent_Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererEvent_Block& operator=(RendererEvent_Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RendererEvent_Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererEvent_Block* internal_default_instance() {
    return reinterpret_cast<const RendererEvent_Block*>(
        &_RendererEvent_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RendererEvent_Block& a, RendererEvent_Block& b) { a.Swap(&b); }
  inline void Swap(RendererEvent_Block* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererEvent_Block* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererEvent_Block* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RendererEvent_Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RendererEvent_Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RendererEvent_Block& from) { RendererEvent_Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RendererEvent_Block* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RendererEvent.Block"; }

 protected:
  explicit RendererEvent_Block(::google::protobuf::Arena* arena);
  RendererEvent_Block(::google::protobuf::Arena* arena, const RendererEvent_Block& from);
  RendererEvent_Block(::google::protobuf::Arena* arena, RendererEvent_Block&& from) noexcept
      : RendererEvent_Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RendererEvent.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RendererEvent_Block_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RendererEvent_Block& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class MouseMoveEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MouseMoveEvent) */ {
 public:
  inline MouseMoveEvent() : MouseMoveEvent(nullptr) {}
  ~MouseMoveEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MouseMoveEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline MouseMoveEvent(const MouseMoveEvent& from) : MouseMoveEvent(nullptr, from) {}
  inline MouseMoveEvent(MouseMoveEvent&& from) noexcept
      : MouseMoveEvent(nullptr, std::move(from)) {}
  inline MouseMoveEvent& operator=(const MouseMoveEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseMoveEvent& operator=(MouseMoveEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseMoveEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseMoveEvent* internal_default_instance() {
    return reinterpret_cast<const MouseMoveEvent*>(
        &_MouseMoveEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(MouseMoveEvent& a, MouseMoveEvent& b) { a.Swap(&b); }
  inline void Swap(MouseMoveEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseMoveEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseMoveEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MouseMoveEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MouseMoveEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MouseMoveEvent& from) { MouseMoveEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MouseMoveEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MouseMoveEvent"; }

 protected:
  explicit MouseMoveEvent(::google::protobuf::Arena* arena);
  MouseMoveEvent(::google::protobuf::Arena* arena, const MouseMoveEvent& from);
  MouseMoveEvent(::google::protobuf::Arena* arena, MouseMoveEvent&& from) noexcept
      : MouseMoveEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXOffsetFieldNumber = 1,
    kYOffsetFieldNumber = 2,
  };
  // double xOffset = 1;
  void clear_xoffset() ;
  double xoffset() const;
  void set_xoffset(double value);

  private:
  double _internal_xoffset() const;
  void _internal_set_xoffset(double value);

  public:
  // double yOffset = 2;
  void clear_yoffset() ;
  double yoffset() const;
  void set_yoffset(double value);

  private:
  double _internal_yoffset() const;
  void _internal_set_yoffset(double value);

  public:
  // @@protoc_insertion_point(class_scope:MouseMoveEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MouseMoveEvent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MouseMoveEvent& from_msg);
    double xoffset_;
    double yoffset_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class CameraEvent_Rotation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CameraEvent.Rotation) */ {
 public:
  inline CameraEvent_Rotation() : CameraEvent_Rotation(nullptr) {}
  ~CameraEvent_Rotation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraEvent_Rotation(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraEvent_Rotation(const CameraEvent_Rotation& from) : CameraEvent_Rotation(nullptr, from) {}
  inline CameraEvent_Rotation(CameraEvent_Rotation&& from) noexcept
      : CameraEvent_Rotation(nullptr, std::move(from)) {}
  inline CameraEvent_Rotation& operator=(const CameraEvent_Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraEvent_Rotation& operator=(CameraEvent_Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraEvent_Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraEvent_Rotation* internal_default_instance() {
    return reinterpret_cast<const CameraEvent_Rotation*>(
        &_CameraEvent_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CameraEvent_Rotation& a, CameraEvent_Rotation& b) { a.Swap(&b); }
  inline void Swap(CameraEvent_Rotation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraEvent_Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraEvent_Rotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CameraEvent_Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraEvent_Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraEvent_Rotation& from) { CameraEvent_Rotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CameraEvent_Rotation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CameraEvent.Rotation"; }

 protected:
  explicit CameraEvent_Rotation(::google::protobuf::Arena* arena);
  CameraEvent_Rotation(::google::protobuf::Arena* arena, const CameraEvent_Rotation& from);
  CameraEvent_Rotation(::google::protobuf::Arena* arena, CameraEvent_Rotation&& from) noexcept
      : CameraEvent_Rotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPitchFieldNumber = 1,
    kYawFieldNumber = 2,
  };
  // double pitch = 1;
  void clear_pitch() ;
  double pitch() const;
  void set_pitch(double value);

  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);

  public:
  // double yaw = 2;
  void clear_yaw() ;
  double yaw() const;
  void set_yaw(double value);

  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);

  public:
  // @@protoc_insertion_point(class_scope:CameraEvent.Rotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CameraEvent_Rotation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraEvent_Rotation& from_msg);
    double pitch_;
    double yaw_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class CameraEvent_Position final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CameraEvent.Position) */ {
 public:
  inline CameraEvent_Position() : CameraEvent_Position(nullptr) {}
  ~CameraEvent_Position() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraEvent_Position(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraEvent_Position(const CameraEvent_Position& from) : CameraEvent_Position(nullptr, from) {}
  inline CameraEvent_Position(CameraEvent_Position&& from) noexcept
      : CameraEvent_Position(nullptr, std::move(from)) {}
  inline CameraEvent_Position& operator=(const CameraEvent_Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraEvent_Position& operator=(CameraEvent_Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraEvent_Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraEvent_Position* internal_default_instance() {
    return reinterpret_cast<const CameraEvent_Position*>(
        &_CameraEvent_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CameraEvent_Position& a, CameraEvent_Position& b) { a.Swap(&b); }
  inline void Swap(CameraEvent_Position* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraEvent_Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraEvent_Position* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CameraEvent_Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraEvent_Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraEvent_Position& from) { CameraEvent_Position::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CameraEvent_Position* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CameraEvent.Position"; }

 protected:
  explicit CameraEvent_Position(::google::protobuf::Arena* arena);
  CameraEvent_Position(::google::protobuf::Arena* arena, const CameraEvent_Position& from);
  CameraEvent_Position(::google::protobuf::Arena* arena, CameraEvent_Position&& from) noexcept
      : CameraEvent_Position(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:CameraEvent.Position)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CameraEvent_Position_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraEvent_Position& from_msg);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class RendererEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RendererEvent) */ {
 public:
  inline RendererEvent() : RendererEvent(nullptr) {}
  ~RendererEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RendererEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline RendererEvent(const RendererEvent& from) : RendererEvent(nullptr, from) {}
  inline RendererEvent(RendererEvent&& from) noexcept
      : RendererEvent(nullptr, std::move(from)) {}
  inline RendererEvent& operator=(const RendererEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererEvent& operator=(RendererEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RendererEvent& default_instance() {
    return *internal_default_instance();
  }
  enum RendererEventCase {
    kNumberValue = 2,
    kBlockValue = 3,
    kBooleanValue = 4,
    kLoadBalancingAlgorithm = 5,
    RENDERER_EVENT_NOT_SET = 0,
  };
  static inline const RendererEvent* internal_default_instance() {
    return reinterpret_cast<const RendererEvent*>(
        &_RendererEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RendererEvent& a, RendererEvent& b) { a.Swap(&b); }
  inline void Swap(RendererEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RendererEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RendererEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RendererEvent& from) { RendererEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RendererEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RendererEvent"; }

 protected:
  explicit RendererEvent(::google::protobuf::Arena* arena);
  RendererEvent(::google::protobuf::Arena* arena, const RendererEvent& from);
  RendererEvent(::google::protobuf::Arena* arena, RendererEvent&& from) noexcept
      : RendererEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Block = RendererEvent_Block;
  using Type = RendererEvent_Type;
  static constexpr Type LOAD_UPLOADED_SCENE = RendererEvent_Type_LOAD_UPLOADED_SCENE;
  static constexpr Type DOWNLOAD_SCENE_SNAPSHOT = RendererEvent_Type_DOWNLOAD_SCENE_SNAPSHOT;
  static constexpr Type GPU_NUMBER = RendererEvent_Type_GPU_NUMBER;
  static constexpr Type STREAMS_PER_GPU = RendererEvent_Type_STREAMS_PER_GPU;
  static constexpr Type SAMPLES_PER_PIXEL = RendererEvent_Type_SAMPLES_PER_PIXEL;
  static constexpr Type RECURSION_DEPTH = RendererEvent_Type_RECURSION_DEPTH;
  static constexpr Type THREAD_BLOCK_SIZE = RendererEvent_Type_THREAD_BLOCK_SIZE;
  static constexpr Type IMAGE_RESOLUTION = RendererEvent_Type_IMAGE_RESOLUTION;
  static constexpr Type SHOW_TASK_GRID = RendererEvent_Type_SHOW_TASK_GRID;
  static constexpr Type LOAD_BALANCING_ALGORITHM = RendererEvent_Type_LOAD_BALANCING_ALGORITHM;
  static inline bool Type_IsValid(int value) {
    return RendererEvent_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RendererEvent_Type_Type_MIN;
  static constexpr Type Type_MAX = RendererEvent_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RendererEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RendererEvent_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RendererEvent_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RendererEvent_Type_Parse(name, value);
  }
  using LoadBalancingAlgorithm = RendererEvent_LoadBalancingAlgorithm;
  static constexpr LoadBalancingAlgorithm FST = RendererEvent_LoadBalancingAlgorithm_FST;
  static constexpr LoadBalancingAlgorithm DTFL = RendererEvent_LoadBalancingAlgorithm_DTFL;
  static constexpr LoadBalancingAlgorithm DT = RendererEvent_LoadBalancingAlgorithm_DT;
  static inline bool LoadBalancingAlgorithm_IsValid(int value) {
    return RendererEvent_LoadBalancingAlgorithm_IsValid(value);
  }
  static constexpr LoadBalancingAlgorithm LoadBalancingAlgorithm_MIN = RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_MIN;
  static constexpr LoadBalancingAlgorithm LoadBalancingAlgorithm_MAX = RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_MAX;
  static constexpr int LoadBalancingAlgorithm_ARRAYSIZE = RendererEvent_LoadBalancingAlgorithm_LoadBalancingAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LoadBalancingAlgorithm_descriptor() {
    return RendererEvent_LoadBalancingAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& LoadBalancingAlgorithm_Name(T value) {
    return RendererEvent_LoadBalancingAlgorithm_Name(value);
  }
  static inline bool LoadBalancingAlgorithm_Parse(absl::string_view name, LoadBalancingAlgorithm* value) {
    return RendererEvent_LoadBalancingAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kNumberValueFieldNumber = 2,
    kBlockValueFieldNumber = 3,
    kBooleanValueFieldNumber = 4,
    kLoadBalancingAlgorithmFieldNumber = 5,
  };
  // .RendererEvent.Type type = 1;
  void clear_type() ;
  ::RendererEvent_Type type() const;
  void set_type(::RendererEvent_Type value);

  private:
  ::RendererEvent_Type _internal_type() const;
  void _internal_set_type(::RendererEvent_Type value);

  public:
  // int32 numberValue = 2;
  bool has_numbervalue() const;
  void clear_numbervalue() ;
  ::int32_t numbervalue() const;
  void set_numbervalue(::int32_t value);

  private:
  ::int32_t _internal_numbervalue() const;
  void _internal_set_numbervalue(::int32_t value);

  public:
  // .RendererEvent.Block blockValue = 3;
  bool has_blockvalue() const;
  private:
  bool _internal_has_blockvalue() const;

  public:
  void clear_blockvalue() ;
  const ::RendererEvent_Block& blockvalue() const;
  PROTOBUF_NODISCARD ::RendererEvent_Block* release_blockvalue();
  ::RendererEvent_Block* mutable_blockvalue();
  void set_allocated_blockvalue(::RendererEvent_Block* value);
  void unsafe_arena_set_allocated_blockvalue(::RendererEvent_Block* value);
  ::RendererEvent_Block* unsafe_arena_release_blockvalue();

  private:
  const ::RendererEvent_Block& _internal_blockvalue() const;
  ::RendererEvent_Block* _internal_mutable_blockvalue();

  public:
  // bool booleanValue = 4;
  bool has_booleanvalue() const;
  void clear_booleanvalue() ;
  bool booleanvalue() const;
  void set_booleanvalue(bool value);

  private:
  bool _internal_booleanvalue() const;
  void _internal_set_booleanvalue(bool value);

  public:
  // .RendererEvent.LoadBalancingAlgorithm loadBalancingAlgorithm = 5;
  bool has_loadbalancingalgorithm() const;
  void clear_loadbalancingalgorithm() ;
  ::RendererEvent_LoadBalancingAlgorithm loadbalancingalgorithm() const;
  void set_loadbalancingalgorithm(::RendererEvent_LoadBalancingAlgorithm value);

  private:
  ::RendererEvent_LoadBalancingAlgorithm _internal_loadbalancingalgorithm() const;
  void _internal_set_loadbalancingalgorithm(::RendererEvent_LoadBalancingAlgorithm value);

  public:
  void clear_renderer_event();
  RendererEventCase renderer_event_case() const;
  // @@protoc_insertion_point(class_scope:RendererEvent)
 private:
  class _Internal;
  void set_has_numbervalue();
  void set_has_blockvalue();
  void set_has_booleanvalue();
  void set_has_loadbalancingalgorithm();
  inline bool has_renderer_event() const;
  inline void clear_has_renderer_event();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RendererEvent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RendererEvent& from_msg);
    int type_;
    union RendererEventUnion {
      constexpr RendererEventUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t numbervalue_;
      ::RendererEvent_Block* blockvalue_;
      bool booleanvalue_;
      int loadbalancingalgorithm_;
    } renderer_event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class CameraEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CameraEvent) */ {
 public:
  inline CameraEvent() : CameraEvent(nullptr) {}
  ~CameraEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraEvent(const CameraEvent& from) : CameraEvent(nullptr, from) {}
  inline CameraEvent(CameraEvent&& from) noexcept
      : CameraEvent(nullptr, std::move(from)) {}
  inline CameraEvent& operator=(const CameraEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraEvent& operator=(CameraEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraEvent& default_instance() {
    return *internal_default_instance();
  }
  enum CameraEventCase {
    kMoveSpeed = 2,
    kPosition = 3,
    kRotation = 4,
    CAMERA_EVENT_NOT_SET = 0,
  };
  static inline const CameraEvent* internal_default_instance() {
    return reinterpret_cast<const CameraEvent*>(
        &_CameraEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CameraEvent& a, CameraEvent& b) { a.Swap(&b); }
  inline void Swap(CameraEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CameraEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraEvent& from) { CameraEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CameraEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CameraEvent"; }

 protected:
  explicit CameraEvent(::google::protobuf::Arena* arena);
  CameraEvent(::google::protobuf::Arena* arena, const CameraEvent& from);
  CameraEvent(::google::protobuf::Arena* arena, CameraEvent&& from) noexcept
      : CameraEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Position = CameraEvent_Position;
  using Rotation = CameraEvent_Rotation;
  using Type = CameraEvent_Type;
  static constexpr Type FORWARD = CameraEvent_Type_FORWARD;
  static constexpr Type BACKWARD = CameraEvent_Type_BACKWARD;
  static constexpr Type LEFT = CameraEvent_Type_LEFT;
  static constexpr Type RIGHT = CameraEvent_Type_RIGHT;
  static constexpr Type UP = CameraEvent_Type_UP;
  static constexpr Type DOWN = CameraEvent_Type_DOWN;
  static constexpr Type FOV_INCREASE = CameraEvent_Type_FOV_INCREASE;
  static constexpr Type FOV_DECREASE = CameraEvent_Type_FOV_DECREASE;
  static constexpr Type PITCH_YAW = CameraEvent_Type_PITCH_YAW;
  static constexpr Type SCENE_POSITION = CameraEvent_Type_SCENE_POSITION;
  static inline bool Type_IsValid(int value) {
    return CameraEvent_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = CameraEvent_Type_Type_MIN;
  static constexpr Type Type_MAX = CameraEvent_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = CameraEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return CameraEvent_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return CameraEvent_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return CameraEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kMoveSpeedFieldNumber = 2,
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
  };
  // .CameraEvent.Type type = 1;
  void clear_type() ;
  ::CameraEvent_Type type() const;
  void set_type(::CameraEvent_Type value);

  private:
  ::CameraEvent_Type _internal_type() const;
  void _internal_set_type(::CameraEvent_Type value);

  public:
  // double moveSpeed = 2;
  bool has_movespeed() const;
  void clear_movespeed() ;
  double movespeed() const;
  void set_movespeed(double value);

  private:
  double _internal_movespeed() const;
  void _internal_set_movespeed(double value);

  public:
  // .CameraEvent.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;

  public:
  void clear_position() ;
  const ::CameraEvent_Position& position() const;
  PROTOBUF_NODISCARD ::CameraEvent_Position* release_position();
  ::CameraEvent_Position* mutable_position();
  void set_allocated_position(::CameraEvent_Position* value);
  void unsafe_arena_set_allocated_position(::CameraEvent_Position* value);
  ::CameraEvent_Position* unsafe_arena_release_position();

  private:
  const ::CameraEvent_Position& _internal_position() const;
  ::CameraEvent_Position* _internal_mutable_position();

  public:
  // .CameraEvent.Rotation rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;

  public:
  void clear_rotation() ;
  const ::CameraEvent_Rotation& rotation() const;
  PROTOBUF_NODISCARD ::CameraEvent_Rotation* release_rotation();
  ::CameraEvent_Rotation* mutable_rotation();
  void set_allocated_rotation(::CameraEvent_Rotation* value);
  void unsafe_arena_set_allocated_rotation(::CameraEvent_Rotation* value);
  ::CameraEvent_Rotation* unsafe_arena_release_rotation();

  private:
  const ::CameraEvent_Rotation& _internal_rotation() const;
  ::CameraEvent_Rotation* _internal_mutable_rotation();

  public:
  void clear_camera_event();
  CameraEventCase camera_event_case() const;
  // @@protoc_insertion_point(class_scope:CameraEvent)
 private:
  class _Internal;
  void set_has_movespeed();
  void set_has_position();
  void set_has_rotation();
  inline bool has_camera_event() const;
  inline void clear_has_camera_event();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CameraEvent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraEvent& from_msg);
    int type_;
    union CameraEventUnion {
      constexpr CameraEventUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double movespeed_;
      ::CameraEvent_Position* position_;
      ::CameraEvent_Rotation* rotation_;
    } camera_event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class Event final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Event(
      ::google::protobuf::internal::ConstantInitialized);

  inline Event(const Event& from) : Event(nullptr, from) {}
  inline Event(Event&& from) noexcept
      : Event(nullptr, std::move(from)) {}
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  enum EventTypeCase {
    kMouseMove = 2,
    kCamera = 3,
    kRenderer = 4,
    EVENT_TYPE_NOT_SET = 0,
  };
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
        &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Event& a, Event& b) { a.Swap(&b); }
  inline void Swap(Event* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Event>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Event& from) { Event::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Event* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Event"; }

 protected:
  explicit Event(::google::protobuf::Arena* arena);
  Event(::google::protobuf::Arena* arena, const Event& from);
  Event(::google::protobuf::Arena* arena, Event&& from) noexcept
      : Event(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EventType = Event_EventType;
  static constexpr EventType UNKNOWN = Event_EventType_UNKNOWN;
  static constexpr EventType MOUSE_MOVE = Event_EventType_MOUSE_MOVE;
  static constexpr EventType CAMERA_EVENT = Event_EventType_CAMERA_EVENT;
  static constexpr EventType RENDERER_EVENT = Event_EventType_RENDERER_EVENT;
  static inline bool EventType_IsValid(int value) {
    return Event_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = Event_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = Event_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = Event_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EventType_descriptor() {
    return Event_EventType_descriptor();
  }
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return Event_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return Event_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kMouseMoveFieldNumber = 2,
    kCameraFieldNumber = 3,
    kRendererFieldNumber = 4,
  };
  // .Event.EventType type = 1;
  void clear_type() ;
  ::Event_EventType type() const;
  void set_type(::Event_EventType value);

  private:
  ::Event_EventType _internal_type() const;
  void _internal_set_type(::Event_EventType value);

  public:
  // .MouseMoveEvent mouseMove = 2;
  bool has_mousemove() const;
  private:
  bool _internal_has_mousemove() const;

  public:
  void clear_mousemove() ;
  const ::MouseMoveEvent& mousemove() const;
  PROTOBUF_NODISCARD ::MouseMoveEvent* release_mousemove();
  ::MouseMoveEvent* mutable_mousemove();
  void set_allocated_mousemove(::MouseMoveEvent* value);
  void unsafe_arena_set_allocated_mousemove(::MouseMoveEvent* value);
  ::MouseMoveEvent* unsafe_arena_release_mousemove();

  private:
  const ::MouseMoveEvent& _internal_mousemove() const;
  ::MouseMoveEvent* _internal_mutable_mousemove();

  public:
  // .CameraEvent camera = 3;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;

  public:
  void clear_camera() ;
  const ::CameraEvent& camera() const;
  PROTOBUF_NODISCARD ::CameraEvent* release_camera();
  ::CameraEvent* mutable_camera();
  void set_allocated_camera(::CameraEvent* value);
  void unsafe_arena_set_allocated_camera(::CameraEvent* value);
  ::CameraEvent* unsafe_arena_release_camera();

  private:
  const ::CameraEvent& _internal_camera() const;
  ::CameraEvent* _internal_mutable_camera();

  public:
  // .RendererEvent renderer = 4;
  bool has_renderer() const;
  private:
  bool _internal_has_renderer() const;

  public:
  void clear_renderer() ;
  const ::RendererEvent& renderer() const;
  PROTOBUF_NODISCARD ::RendererEvent* release_renderer();
  ::RendererEvent* mutable_renderer();
  void set_allocated_renderer(::RendererEvent* value);
  void unsafe_arena_set_allocated_renderer(::RendererEvent* value);
  ::RendererEvent* unsafe_arena_release_renderer();

  private:
  const ::RendererEvent& _internal_renderer() const;
  ::RendererEvent* _internal_mutable_renderer();

  public:
  void clear_event_type();
  EventTypeCase event_type_case() const;
  // @@protoc_insertion_point(class_scope:Event)
 private:
  class _Internal;
  void set_has_mousemove();
  void set_has_camera();
  void set_has_renderer();
  inline bool has_event_type() const;
  inline void clear_has_event_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Event_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Event& from_msg);
    int type_;
    union EventTypeUnion {
      constexpr EventTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::MouseMoveEvent* mousemove_;
      ::CameraEvent* camera_;
      ::RendererEvent* renderer_;
    } event_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_main_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MouseMoveEvent

// double xOffset = 1;
inline void MouseMoveEvent::clear_xoffset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xoffset_ = 0;
}
inline double MouseMoveEvent::xoffset() const {
  // @@protoc_insertion_point(field_get:MouseMoveEvent.xOffset)
  return _internal_xoffset();
}
inline void MouseMoveEvent::set_xoffset(double value) {
  _internal_set_xoffset(value);
  // @@protoc_insertion_point(field_set:MouseMoveEvent.xOffset)
}
inline double MouseMoveEvent::_internal_xoffset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xoffset_;
}
inline void MouseMoveEvent::_internal_set_xoffset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xoffset_ = value;
}

// double yOffset = 2;
inline void MouseMoveEvent::clear_yoffset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yoffset_ = 0;
}
inline double MouseMoveEvent::yoffset() const {
  // @@protoc_insertion_point(field_get:MouseMoveEvent.yOffset)
  return _internal_yoffset();
}
inline void MouseMoveEvent::set_yoffset(double value) {
  _internal_set_yoffset(value);
  // @@protoc_insertion_point(field_set:MouseMoveEvent.yOffset)
}
inline double MouseMoveEvent::_internal_yoffset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yoffset_;
}
inline void MouseMoveEvent::_internal_set_yoffset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yoffset_ = value;
}

// -------------------------------------------------------------------

// CameraEvent_Position

// double x = 1;
inline void CameraEvent_Position::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline double CameraEvent_Position::x() const {
  // @@protoc_insertion_point(field_get:CameraEvent.Position.x)
  return _internal_x();
}
inline void CameraEvent_Position::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CameraEvent.Position.x)
}
inline double CameraEvent_Position::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void CameraEvent_Position::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// double y = 2;
inline void CameraEvent_Position::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline double CameraEvent_Position::y() const {
  // @@protoc_insertion_point(field_get:CameraEvent.Position.y)
  return _internal_y();
}
inline void CameraEvent_Position::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CameraEvent.Position.y)
}
inline double CameraEvent_Position::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void CameraEvent_Position::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// double z = 3;
inline void CameraEvent_Position::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline double CameraEvent_Position::z() const {
  // @@protoc_insertion_point(field_get:CameraEvent.Position.z)
  return _internal_z();
}
inline void CameraEvent_Position::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:CameraEvent.Position.z)
}
inline double CameraEvent_Position::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void CameraEvent_Position::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// CameraEvent_Rotation

// double pitch = 1;
inline void CameraEvent_Rotation::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = 0;
}
inline double CameraEvent_Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:CameraEvent.Rotation.pitch)
  return _internal_pitch();
}
inline void CameraEvent_Rotation::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:CameraEvent.Rotation.pitch)
}
inline double CameraEvent_Rotation::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pitch_;
}
inline void CameraEvent_Rotation::_internal_set_pitch(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = value;
}

// double yaw = 2;
inline void CameraEvent_Rotation::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = 0;
}
inline double CameraEvent_Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:CameraEvent.Rotation.yaw)
  return _internal_yaw();
}
inline void CameraEvent_Rotation::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:CameraEvent.Rotation.yaw)
}
inline double CameraEvent_Rotation::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yaw_;
}
inline void CameraEvent_Rotation::_internal_set_yaw(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = value;
}

// -------------------------------------------------------------------

// CameraEvent

// .CameraEvent.Type type = 1;
inline void CameraEvent::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::CameraEvent_Type CameraEvent::type() const {
  // @@protoc_insertion_point(field_get:CameraEvent.type)
  return _internal_type();
}
inline void CameraEvent::set_type(::CameraEvent_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CameraEvent.type)
}
inline ::CameraEvent_Type CameraEvent::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::CameraEvent_Type>(_impl_.type_);
}
inline void CameraEvent::_internal_set_type(::CameraEvent_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// double moveSpeed = 2;
inline bool CameraEvent::has_movespeed() const {
  return camera_event_case() == kMoveSpeed;
}
inline void CameraEvent::set_has_movespeed() {
  _impl_._oneof_case_[0] = kMoveSpeed;
}
inline void CameraEvent::clear_movespeed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (camera_event_case() == kMoveSpeed) {
    _impl_.camera_event_.movespeed_ = 0;
    clear_has_camera_event();
  }
}
inline double CameraEvent::movespeed() const {
  // @@protoc_insertion_point(field_get:CameraEvent.moveSpeed)
  return _internal_movespeed();
}
inline void CameraEvent::set_movespeed(double value) {
  if (camera_event_case() != kMoveSpeed) {
    clear_camera_event();
    set_has_movespeed();
  }
  _impl_.camera_event_.movespeed_ = value;
  // @@protoc_insertion_point(field_set:CameraEvent.moveSpeed)
}
inline double CameraEvent::_internal_movespeed() const {
  if (camera_event_case() == kMoveSpeed) {
    return _impl_.camera_event_.movespeed_;
  }
  return 0;
}

// .CameraEvent.Position position = 3;
inline bool CameraEvent::has_position() const {
  return camera_event_case() == kPosition;
}
inline bool CameraEvent::_internal_has_position() const {
  return camera_event_case() == kPosition;
}
inline void CameraEvent::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void CameraEvent::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (camera_event_case() == kPosition) {
    if (GetArena() == nullptr) {
      delete _impl_.camera_event_.position_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.camera_event_.position_);
    }
    clear_has_camera_event();
  }
}
inline ::CameraEvent_Position* CameraEvent::release_position() {
  // @@protoc_insertion_point(field_release:CameraEvent.position)
  if (camera_event_case() == kPosition) {
    clear_has_camera_event();
    auto* temp = _impl_.camera_event_.position_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.camera_event_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CameraEvent_Position& CameraEvent::_internal_position() const {
  return camera_event_case() == kPosition ? *_impl_.camera_event_.position_ : reinterpret_cast<::CameraEvent_Position&>(::_CameraEvent_Position_default_instance_);
}
inline const ::CameraEvent_Position& CameraEvent::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CameraEvent.position)
  return _internal_position();
}
inline ::CameraEvent_Position* CameraEvent::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CameraEvent.position)
  if (camera_event_case() == kPosition) {
    clear_has_camera_event();
    auto* temp = _impl_.camera_event_.position_;
    _impl_.camera_event_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CameraEvent::unsafe_arena_set_allocated_position(::CameraEvent_Position* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_camera_event();
  if (value) {
    set_has_position();
    _impl_.camera_event_.position_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CameraEvent.position)
}
inline ::CameraEvent_Position* CameraEvent::_internal_mutable_position() {
  if (camera_event_case() != kPosition) {
    clear_camera_event();
    set_has_position();
    _impl_.camera_event_.position_ =
        ::google::protobuf::Message::DefaultConstruct<::CameraEvent_Position>(GetArena());
  }
  return _impl_.camera_event_.position_;
}
inline ::CameraEvent_Position* CameraEvent::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CameraEvent_Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:CameraEvent.position)
  return _msg;
}

// .CameraEvent.Rotation rotation = 4;
inline bool CameraEvent::has_rotation() const {
  return camera_event_case() == kRotation;
}
inline bool CameraEvent::_internal_has_rotation() const {
  return camera_event_case() == kRotation;
}
inline void CameraEvent::set_has_rotation() {
  _impl_._oneof_case_[0] = kRotation;
}
inline void CameraEvent::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (camera_event_case() == kRotation) {
    if (GetArena() == nullptr) {
      delete _impl_.camera_event_.rotation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.camera_event_.rotation_);
    }
    clear_has_camera_event();
  }
}
inline ::CameraEvent_Rotation* CameraEvent::release_rotation() {
  // @@protoc_insertion_point(field_release:CameraEvent.rotation)
  if (camera_event_case() == kRotation) {
    clear_has_camera_event();
    auto* temp = _impl_.camera_event_.rotation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.camera_event_.rotation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CameraEvent_Rotation& CameraEvent::_internal_rotation() const {
  return camera_event_case() == kRotation ? *_impl_.camera_event_.rotation_ : reinterpret_cast<::CameraEvent_Rotation&>(::_CameraEvent_Rotation_default_instance_);
}
inline const ::CameraEvent_Rotation& CameraEvent::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CameraEvent.rotation)
  return _internal_rotation();
}
inline ::CameraEvent_Rotation* CameraEvent::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CameraEvent.rotation)
  if (camera_event_case() == kRotation) {
    clear_has_camera_event();
    auto* temp = _impl_.camera_event_.rotation_;
    _impl_.camera_event_.rotation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CameraEvent::unsafe_arena_set_allocated_rotation(::CameraEvent_Rotation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_camera_event();
  if (value) {
    set_has_rotation();
    _impl_.camera_event_.rotation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CameraEvent.rotation)
}
inline ::CameraEvent_Rotation* CameraEvent::_internal_mutable_rotation() {
  if (camera_event_case() != kRotation) {
    clear_camera_event();
    set_has_rotation();
    _impl_.camera_event_.rotation_ =
        ::google::protobuf::Message::DefaultConstruct<::CameraEvent_Rotation>(GetArena());
  }
  return _impl_.camera_event_.rotation_;
}
inline ::CameraEvent_Rotation* CameraEvent::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CameraEvent_Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:CameraEvent.rotation)
  return _msg;
}

inline bool CameraEvent::has_camera_event() const {
  return camera_event_case() != CAMERA_EVENT_NOT_SET;
}
inline void CameraEvent::clear_has_camera_event() {
  _impl_._oneof_case_[0] = CAMERA_EVENT_NOT_SET;
}
inline CameraEvent::CameraEventCase CameraEvent::camera_event_case() const {
  return CameraEvent::CameraEventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RendererEvent_Block

// int32 x = 1;
inline void RendererEvent_Block::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t RendererEvent_Block::x() const {
  // @@protoc_insertion_point(field_get:RendererEvent.Block.x)
  return _internal_x();
}
inline void RendererEvent_Block::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:RendererEvent.Block.x)
}
inline ::int32_t RendererEvent_Block::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void RendererEvent_Block::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void RendererEvent_Block::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t RendererEvent_Block::y() const {
  // @@protoc_insertion_point(field_get:RendererEvent.Block.y)
  return _internal_y();
}
inline void RendererEvent_Block::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:RendererEvent.Block.y)
}
inline ::int32_t RendererEvent_Block::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void RendererEvent_Block::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// RendererEvent

// .RendererEvent.Type type = 1;
inline void RendererEvent::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::RendererEvent_Type RendererEvent::type() const {
  // @@protoc_insertion_point(field_get:RendererEvent.type)
  return _internal_type();
}
inline void RendererEvent::set_type(::RendererEvent_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RendererEvent.type)
}
inline ::RendererEvent_Type RendererEvent::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::RendererEvent_Type>(_impl_.type_);
}
inline void RendererEvent::_internal_set_type(::RendererEvent_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// int32 numberValue = 2;
inline bool RendererEvent::has_numbervalue() const {
  return renderer_event_case() == kNumberValue;
}
inline void RendererEvent::set_has_numbervalue() {
  _impl_._oneof_case_[0] = kNumberValue;
}
inline void RendererEvent::clear_numbervalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (renderer_event_case() == kNumberValue) {
    _impl_.renderer_event_.numbervalue_ = 0;
    clear_has_renderer_event();
  }
}
inline ::int32_t RendererEvent::numbervalue() const {
  // @@protoc_insertion_point(field_get:RendererEvent.numberValue)
  return _internal_numbervalue();
}
inline void RendererEvent::set_numbervalue(::int32_t value) {
  if (renderer_event_case() != kNumberValue) {
    clear_renderer_event();
    set_has_numbervalue();
  }
  _impl_.renderer_event_.numbervalue_ = value;
  // @@protoc_insertion_point(field_set:RendererEvent.numberValue)
}
inline ::int32_t RendererEvent::_internal_numbervalue() const {
  if (renderer_event_case() == kNumberValue) {
    return _impl_.renderer_event_.numbervalue_;
  }
  return 0;
}

// .RendererEvent.Block blockValue = 3;
inline bool RendererEvent::has_blockvalue() const {
  return renderer_event_case() == kBlockValue;
}
inline bool RendererEvent::_internal_has_blockvalue() const {
  return renderer_event_case() == kBlockValue;
}
inline void RendererEvent::set_has_blockvalue() {
  _impl_._oneof_case_[0] = kBlockValue;
}
inline void RendererEvent::clear_blockvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (renderer_event_case() == kBlockValue) {
    if (GetArena() == nullptr) {
      delete _impl_.renderer_event_.blockvalue_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.renderer_event_.blockvalue_);
    }
    clear_has_renderer_event();
  }
}
inline ::RendererEvent_Block* RendererEvent::release_blockvalue() {
  // @@protoc_insertion_point(field_release:RendererEvent.blockValue)
  if (renderer_event_case() == kBlockValue) {
    clear_has_renderer_event();
    auto* temp = _impl_.renderer_event_.blockvalue_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.renderer_event_.blockvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RendererEvent_Block& RendererEvent::_internal_blockvalue() const {
  return renderer_event_case() == kBlockValue ? *_impl_.renderer_event_.blockvalue_ : reinterpret_cast<::RendererEvent_Block&>(::_RendererEvent_Block_default_instance_);
}
inline const ::RendererEvent_Block& RendererEvent::blockvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RendererEvent.blockValue)
  return _internal_blockvalue();
}
inline ::RendererEvent_Block* RendererEvent::unsafe_arena_release_blockvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendererEvent.blockValue)
  if (renderer_event_case() == kBlockValue) {
    clear_has_renderer_event();
    auto* temp = _impl_.renderer_event_.blockvalue_;
    _impl_.renderer_event_.blockvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendererEvent::unsafe_arena_set_allocated_blockvalue(::RendererEvent_Block* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_renderer_event();
  if (value) {
    set_has_blockvalue();
    _impl_.renderer_event_.blockvalue_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendererEvent.blockValue)
}
inline ::RendererEvent_Block* RendererEvent::_internal_mutable_blockvalue() {
  if (renderer_event_case() != kBlockValue) {
    clear_renderer_event();
    set_has_blockvalue();
    _impl_.renderer_event_.blockvalue_ =
        ::google::protobuf::Message::DefaultConstruct<::RendererEvent_Block>(GetArena());
  }
  return _impl_.renderer_event_.blockvalue_;
}
inline ::RendererEvent_Block* RendererEvent::mutable_blockvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RendererEvent_Block* _msg = _internal_mutable_blockvalue();
  // @@protoc_insertion_point(field_mutable:RendererEvent.blockValue)
  return _msg;
}

// bool booleanValue = 4;
inline bool RendererEvent::has_booleanvalue() const {
  return renderer_event_case() == kBooleanValue;
}
inline void RendererEvent::set_has_booleanvalue() {
  _impl_._oneof_case_[0] = kBooleanValue;
}
inline void RendererEvent::clear_booleanvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (renderer_event_case() == kBooleanValue) {
    _impl_.renderer_event_.booleanvalue_ = false;
    clear_has_renderer_event();
  }
}
inline bool RendererEvent::booleanvalue() const {
  // @@protoc_insertion_point(field_get:RendererEvent.booleanValue)
  return _internal_booleanvalue();
}
inline void RendererEvent::set_booleanvalue(bool value) {
  if (renderer_event_case() != kBooleanValue) {
    clear_renderer_event();
    set_has_booleanvalue();
  }
  _impl_.renderer_event_.booleanvalue_ = value;
  // @@protoc_insertion_point(field_set:RendererEvent.booleanValue)
}
inline bool RendererEvent::_internal_booleanvalue() const {
  if (renderer_event_case() == kBooleanValue) {
    return _impl_.renderer_event_.booleanvalue_;
  }
  return false;
}

// .RendererEvent.LoadBalancingAlgorithm loadBalancingAlgorithm = 5;
inline bool RendererEvent::has_loadbalancingalgorithm() const {
  return renderer_event_case() == kLoadBalancingAlgorithm;
}
inline void RendererEvent::set_has_loadbalancingalgorithm() {
  _impl_._oneof_case_[0] = kLoadBalancingAlgorithm;
}
inline void RendererEvent::clear_loadbalancingalgorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (renderer_event_case() == kLoadBalancingAlgorithm) {
    _impl_.renderer_event_.loadbalancingalgorithm_ = 0;
    clear_has_renderer_event();
  }
}
inline ::RendererEvent_LoadBalancingAlgorithm RendererEvent::loadbalancingalgorithm() const {
  // @@protoc_insertion_point(field_get:RendererEvent.loadBalancingAlgorithm)
  return _internal_loadbalancingalgorithm();
}
inline void RendererEvent::set_loadbalancingalgorithm(::RendererEvent_LoadBalancingAlgorithm value) {
  if (renderer_event_case() != kLoadBalancingAlgorithm) {
    clear_renderer_event();
    set_has_loadbalancingalgorithm();
  }
  _impl_.renderer_event_.loadbalancingalgorithm_ = value;
  // @@protoc_insertion_point(field_set:RendererEvent.loadBalancingAlgorithm)
}
inline ::RendererEvent_LoadBalancingAlgorithm RendererEvent::_internal_loadbalancingalgorithm() const {
  if (renderer_event_case() == kLoadBalancingAlgorithm) {
    return static_cast<::RendererEvent_LoadBalancingAlgorithm>(_impl_.renderer_event_.loadbalancingalgorithm_);
  }
  return static_cast<::RendererEvent_LoadBalancingAlgorithm>(0);
}

inline bool RendererEvent::has_renderer_event() const {
  return renderer_event_case() != RENDERER_EVENT_NOT_SET;
}
inline void RendererEvent::clear_has_renderer_event() {
  _impl_._oneof_case_[0] = RENDERER_EVENT_NOT_SET;
}
inline RendererEvent::RendererEventCase RendererEvent::renderer_event_case() const {
  return RendererEvent::RendererEventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// .Event.EventType type = 1;
inline void Event::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::Event_EventType Event::type() const {
  // @@protoc_insertion_point(field_get:Event.type)
  return _internal_type();
}
inline void Event::set_type(::Event_EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Event.type)
}
inline ::Event_EventType Event::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Event_EventType>(_impl_.type_);
}
inline void Event::_internal_set_type(::Event_EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .MouseMoveEvent mouseMove = 2;
inline bool Event::has_mousemove() const {
  return event_type_case() == kMouseMove;
}
inline bool Event::_internal_has_mousemove() const {
  return event_type_case() == kMouseMove;
}
inline void Event::set_has_mousemove() {
  _impl_._oneof_case_[0] = kMouseMove;
}
inline void Event::clear_mousemove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kMouseMove) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.mousemove_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.mousemove_);
    }
    clear_has_event_type();
  }
}
inline ::MouseMoveEvent* Event::release_mousemove() {
  // @@protoc_insertion_point(field_release:Event.mouseMove)
  if (event_type_case() == kMouseMove) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.mousemove_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.mousemove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MouseMoveEvent& Event::_internal_mousemove() const {
  return event_type_case() == kMouseMove ? *_impl_.event_type_.mousemove_ : reinterpret_cast<::MouseMoveEvent&>(::_MouseMoveEvent_default_instance_);
}
inline const ::MouseMoveEvent& Event::mousemove() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Event.mouseMove)
  return _internal_mousemove();
}
inline ::MouseMoveEvent* Event::unsafe_arena_release_mousemove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Event.mouseMove)
  if (event_type_case() == kMouseMove) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.mousemove_;
    _impl_.event_type_.mousemove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_mousemove(::MouseMoveEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_mousemove();
    _impl_.event_type_.mousemove_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Event.mouseMove)
}
inline ::MouseMoveEvent* Event::_internal_mutable_mousemove() {
  if (event_type_case() != kMouseMove) {
    clear_event_type();
    set_has_mousemove();
    _impl_.event_type_.mousemove_ =
        ::google::protobuf::Message::DefaultConstruct<::MouseMoveEvent>(GetArena());
  }
  return _impl_.event_type_.mousemove_;
}
inline ::MouseMoveEvent* Event::mutable_mousemove() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MouseMoveEvent* _msg = _internal_mutable_mousemove();
  // @@protoc_insertion_point(field_mutable:Event.mouseMove)
  return _msg;
}

// .CameraEvent camera = 3;
inline bool Event::has_camera() const {
  return event_type_case() == kCamera;
}
inline bool Event::_internal_has_camera() const {
  return event_type_case() == kCamera;
}
inline void Event::set_has_camera() {
  _impl_._oneof_case_[0] = kCamera;
}
inline void Event::clear_camera() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kCamera) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.camera_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.camera_);
    }
    clear_has_event_type();
  }
}
inline ::CameraEvent* Event::release_camera() {
  // @@protoc_insertion_point(field_release:Event.camera)
  if (event_type_case() == kCamera) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.camera_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CameraEvent& Event::_internal_camera() const {
  return event_type_case() == kCamera ? *_impl_.event_type_.camera_ : reinterpret_cast<::CameraEvent&>(::_CameraEvent_default_instance_);
}
inline const ::CameraEvent& Event::camera() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Event.camera)
  return _internal_camera();
}
inline ::CameraEvent* Event::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Event.camera)
  if (event_type_case() == kCamera) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.camera_;
    _impl_.event_type_.camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_camera(::CameraEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_camera();
    _impl_.event_type_.camera_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Event.camera)
}
inline ::CameraEvent* Event::_internal_mutable_camera() {
  if (event_type_case() != kCamera) {
    clear_event_type();
    set_has_camera();
    _impl_.event_type_.camera_ =
        ::google::protobuf::Message::DefaultConstruct<::CameraEvent>(GetArena());
  }
  return _impl_.event_type_.camera_;
}
inline ::CameraEvent* Event::mutable_camera() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CameraEvent* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:Event.camera)
  return _msg;
}

// .RendererEvent renderer = 4;
inline bool Event::has_renderer() const {
  return event_type_case() == kRenderer;
}
inline bool Event::_internal_has_renderer() const {
  return event_type_case() == kRenderer;
}
inline void Event::set_has_renderer() {
  _impl_._oneof_case_[0] = kRenderer;
}
inline void Event::clear_renderer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kRenderer) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.renderer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.renderer_);
    }
    clear_has_event_type();
  }
}
inline ::RendererEvent* Event::release_renderer() {
  // @@protoc_insertion_point(field_release:Event.renderer)
  if (event_type_case() == kRenderer) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.renderer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.renderer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RendererEvent& Event::_internal_renderer() const {
  return event_type_case() == kRenderer ? *_impl_.event_type_.renderer_ : reinterpret_cast<::RendererEvent&>(::_RendererEvent_default_instance_);
}
inline const ::RendererEvent& Event::renderer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Event.renderer)
  return _internal_renderer();
}
inline ::RendererEvent* Event::unsafe_arena_release_renderer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Event.renderer)
  if (event_type_case() == kRenderer) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.renderer_;
    _impl_.event_type_.renderer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_renderer(::RendererEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_renderer();
    _impl_.event_type_.renderer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Event.renderer)
}
inline ::RendererEvent* Event::_internal_mutable_renderer() {
  if (event_type_case() != kRenderer) {
    clear_event_type();
    set_has_renderer();
    _impl_.event_type_.renderer_ =
        ::google::protobuf::Message::DefaultConstruct<::RendererEvent>(GetArena());
  }
  return _impl_.event_type_.renderer_;
}
inline ::RendererEvent* Event::mutable_renderer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RendererEvent* _msg = _internal_mutable_renderer();
  // @@protoc_insertion_point(field_mutable:Event.renderer)
  return _msg;
}

inline bool Event::has_event_type() const {
  return event_type_case() != EVENT_TYPE_NOT_SET;
}
inline void Event::clear_has_event_type() {
  _impl_._oneof_case_[0] = EVENT_TYPE_NOT_SET;
}
inline Event::EventTypeCase Event::event_type_case() const {
  return Event::EventTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::CameraEvent_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CameraEvent_Type>() {
  return ::CameraEvent_Type_descriptor();
}
template <>
struct is_proto_enum<::RendererEvent_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::RendererEvent_Type>() {
  return ::RendererEvent_Type_descriptor();
}
template <>
struct is_proto_enum<::RendererEvent_LoadBalancingAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::RendererEvent_LoadBalancingAlgorithm>() {
  return ::RendererEvent_LoadBalancingAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::Event_EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Event_EventType>() {
  return ::Event_EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_main_2eproto_2epb_2eh
